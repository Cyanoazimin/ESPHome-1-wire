esphome:
  name: warmwasserspeicher
  friendly_name: ESP32 Warmwasserspeicher Gastherme

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Hier sagen wir ESPHome, dass es die lokalen Dateien nutzen soll
external_components:
  - source:
      type: local
      path: my_components

# Enable Home Assistant API
api:
  encryption:
    key: !secret haapi_password

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 15min

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Warmwasserspeicher"
    password: !secret ap_password

mqtt:
  broker: 192.168.178.91
  port: 1883
  username: !secret "mqtt_username"
  password: !secret "mqtt_password"
  discovery: false

# 1-Wire BUS an GPIO 4
one_wire:
  - platform: gpio
    pin: GPIO4
    id: dallas_bus

sensor:
  # Sensor 1: Warmwasser Oben
  - platform: dallas_temp
    address: 0xf74bc78711646128
    name: "Temperatur Warmwasserspeicher Oben"
    force_update: true
    id: TDHWO
    update_interval: 30s
    on_value:
      then:
        - mqtt.publish:
            topic: "S40C/T/D/H/WO"
            payload: !lambda 'return str_sprintf("%.2f", x);'
            retain: true
            qos: 1

  # Sensor 2: Warmwasser Mitte
  - platform: dallas_temp
    address: 0xd56dc98711646128
    name: "Temperatur Warmwasserspeicher Mitte"
    force_update: true
    id: TDHWM
    update_interval: 30s
    on_value:
      then:
        - mqtt.publish:
            topic: "S40C/T/D/H/WM"
            payload: !lambda 'return str_sprintf("%.2f", x);'
            retain: true
            qos: 1

  # Sensor 3: Warmwasser Unten
  - platform: dallas_temp
    address: 0xd4041670cdc5ff28
    name: "Temperatur Warmwasserspeicher Unten"
    force_update: true
    id: TDHWU
    update_interval: 30s
    on_value:
      then:
        - mqtt.publish:
            topic: "S40C/T/D/H/WU"
            payload: !lambda 'return str_sprintf("%.2f", x);'
            retain: true
            qos: 1

  # Custom DS2438 Sensor
  - platform: ds2438
    one_wire_id: dallas_bus
    address: 0x0e000001766f4226
    update_interval: 30s
    shunt_resistance: 0.1

    # Temperatur
    temperature:
      name: "Temperatur Haube Warmwasserspeicher"
      force_update: true
      unit_of_measurement: "°C"
      accuracy_decimals: 1
      on_value:
        then:
          - mqtt.publish:
              topic: "S40C/T/D/W/7I"
              payload: !lambda 'return str_sprintf("%.2f", x);'
              retain: true
              qos: 1

    # Spannung 1: VAD (Titanelektrode gegen Gehäuse)
    voltage:
      id: vad_voltage
      name: "Korrosionsschutzspannung"
      force_update: true
      unit_of_measurement: "V"
      accuracy_decimals: 2
      on_value:
        then:
          - mqtt.publish:
              topic: "S40C/V/D/W/SI"
              payload: !lambda 'return str_sprintf("%.2f", x);'
              retain: true
              qos: 1

    # Spannung 2: VDD (Bus Versorgungsspannung)
    bus_voltage:
      name: "Versorgungsspannung Bus"
      force_update: true
      unit_of_measurement: "V"
      accuracy_decimals: 2
      on_value:
        then:
          - mqtt.publish:
              topic: "S40C/V/D/W/VI"
              payload: !lambda 'return str_sprintf("%.2f", x);'
              retain: true
              qos: 1

    # Strom (durch shunt_resistance)
    current:
      id: iad_current
      name: "Schutzstrom in Kathode"
      unit_of_measurement: "A"
      accuracy_decimals: 5
      on_value:
        then:
          - mqtt.publish:
              topic: "S40C/S/D/W/7I"
              payload: !lambda 'return str_sprintf("%.5f", x);'
              retain: true
              qos: 1
              
binary_sensor:
  - platform: template
    name: "Korrosionsschutz Alarm"
    id: corrosion_alarm
    lambda: |-
      // Constants from Linear Regression (P = m*T + c)
      // m = 0.9735, c = -27.34
      const float m = 0.9735;
      const float c = -27.34;
      
      // Get current values
      // Temp is in TDHWO (Top of tank), usually the hottest and most relevant for the anode head
      if (!id(TDHWO).has_state() || !id(vad_voltage).has_state() || !id(iad_current).has_state()) {
        return false;
      }

      float t = id(TDHWO).state; 
      float v = id(vad_voltage).state; 
      float i = id(iad_current).state; 
      
      // Calculate Actual Power in µW (V * A * 1e6)
      float p_actual = v * i * 1000000.0;
      
      // Calculate Expected Power in µW
      float p_expected = (m * t) + c;
      if (p_expected < 0) p_expected = 0; // Clamp negative values at low temps
      
      // Calculate Deviation
      float deviation = abs(p_actual - p_expected);
      
      // Threshold: 10 µW
      // Triggers if deviation is too high (e.g. cable break -> 0 µW vs expected 16 µW)
      return deviation > 10.0;
    filters:
      - delayed_on: 1min # Prevent false alarms during reading fluctuations

 captive_portal: